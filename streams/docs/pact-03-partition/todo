x need good estimator of how much overhead we add in splitjoin fusion.
Actually could be good research goal to bring this overhead to a
minimum.

  - for now just doing this with fusing filters directly... fusing
    the result of fusion could be tricky?

- fission in the greedy partitioner is pretty stupid because it can't
fiss 2-stage filters that peek -- thus each filter only gets fissed
once.

- the whole thing with sometims returning the new result and sometimes
mutating the parent instead is misleading, esp. for toplevel parents
where something should be returned but often it is assumed that it is
mutated (e.g. lifter)

* actually look at the applications and speculate where dynamic
programming would fundamentally help over something greedy

- extend algorithm description to include joiners in the middle of 2-D
stuff

- need to fix 2-stage filter fusion (look like regtest dying in ~7 places)

- think about application to feedbackloops

GENERAL

- get someone to do a moratorium on all the options and figure out
what the best combination is.

--------------------------------------------------------------

paper:

- add 2-stage filters to the fission descriptions?

- add pipeline fission

- in algorithm write-up, can incorporate data or code size by
replacing "sum" with a generic operator * and then defining * to be +
in the case of just summing, but + with a threshold otherwise... also
modify traceback, e.g., to pick a given cost with the FEWEST number of
nodes.  (can do this by just repeatedly calling with 1, 2, ... N until
you get the same cost at the top level).

theoretical:

- how to do pipeline fission, e.g. in FFT - since joiners will still
exist if each node is fissed individually, need to consider pipeline
fission on the whole.  Or guarantee somehow that sync removal can work
afterwards.  (After fission, could annotate the splitjoin that the
multiplicity of each parallel stream can be scaled if it facilitates
joiner removal.)

- problem with first doing fission of filters inside a splitjoin and
then slicing them horizontally, together.  this is allowed with the
transformations of our framework but we wouldn't find it in current
formulation.

- hmm, seems like a simple transformatin to roerder the parallel
streams of a duplicate splitjoin (either introducing a reordering node
below, or programming the roundrobin to input things in a different
order.)  But I guess our framework doesn't support this.

- how to deal with gordo's new joiner elimination stuff

implementation:

 - 2D partitioning
 - 2-stage pipeline fusion (Jasper)  (vocoder/nokia waiting on it)
 - feedbackloop fusion

 - backout of unfusable filters (or find way to fuse them) - file
   readers and writers, etc.

 - (low priority) uniform splitjoin optimization
 - (low priority) don't fuse more than you have to?

results:

* in fft, i don't know

* in beamformer, input generate and detector is a problem because they
have counters that loop around.  there should be a transformation to
move state inside a work function if it's periodically reset so that
filter can be duplicated.  also need to use coarsebeamformer instead
of the plain one because of state in the fir filters.

* in bitonic sort, the source might be stateful if the elements of A
aren't being propagated... but they should be propagated.

extensions:

 - consider interaction with time-multiplexing

 - consider interaction with sync removal

 - doesn't realize that the result of SIMPLE splitjoin fusion is a
   3-stage pipeline (in case it wanted to preserve some of these
   cases)

bugs:

* on bitonic sort with --raw 4, partitioner is off-by-one.

- blocked matrix multiply causes deadlock when fission is turned on
