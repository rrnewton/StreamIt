questions for karczma:
- how about my replacement scheme
- can we rename the package to "iterator"?
- do we really need IteratorBase -- please move getObject into each indiv. one?  hmm.

----------

Interface:

Iterator getMutableCopy(Iterator i);
  - does cloning
  - replaces in parents by shallowclone and replacement

Iterator finalize(Iterator i);
  - does finalization of contained stream structures
  - does structural equality test
  - replaces in parents by shallowclone and replacement

----------

Then to implement:

* Change the children to be from the init function to be (stream,
args) pairs within the construct, to make replacing easier.

- In all the mutator methods of the classes, make sure you're not
finalized.

- Go through the IR and start to patch things up.

----------

NOTES for when I announce it to people:

1. Beware that you can never have any backward pointers in the
top-level of the IR, or the reflection will break.  If we really need
to add one, we could special-case the reflection not to follow the
fields.

---------

Random notes:

- for tracing up to the root, probably want a shallowClone method that
instantiates a new stream construct and copies over all fields into it.

- what to do with fields of stream constructs?  do you need to check
  out a separate copy for them, too, or do they just come with their
  parent?  I think I'd prefer to have them come with their parent.

- Also, an easier way to implement the whole immutable thing might be
  to replace the copy in all of your parents when you check out an
  immutable version.  Although I guess doing when you finalize might
  also be okay... but the iterator is a little bit weird then, 'cause
  it doesn't really know all of its parents.

- I guess you need to finalize each individual filter?  This is again
  an advantage of doing the replacement when you ask for the
  modification, maybe, since after the parser it could be a little bit
  messy to go straight to modifying.  So I guess if you ask to
  finalize a pipeline, you first have to finalize its pieces.  Sure.
  But I don't feel like writing field modifiers, so let's just make
  them part of the filter.  (when a filter becomes immutable, so does
  the field.)

- So I like a model where you start with an iterator, and you ask for
  an iterator that's a new (modifyable) branch of the tree.  This will
  already be replaced in all its parents; all you need to do is
  finalize it.  Then you can get the object from the iterator and
  finalize it.  Whenever you finalize an object, it finalizes all of
  its children as well.

  --> oh, but the idea is that when you finalize, you might want a
      different object (one that's already been modified) so you
      really shouldn't do the replacing 'til then.

----

so this design would be kind of segmented / cliff-oriented /
two-parted (ugh what's the word) in that you have iterator support for
objects up through what you're modifying, and from there under it is
completely just object references.  So for instance there's no way to
commit a filter if you haven't committed it's parent yet, since you
won't have an iterator to that filter (since there's no iterator for
the parent, because the parent is being modified and is not part of
the tree yet.)

// get a mutable copy of the object <o>, which will happen by normal
// cloning
 Object getMutableCopy(object o);

// replace object pointed to by <i> with <o> and return a new pointer
// to that object.
Iterator finalize(object o, iterator i);  

#2: I guess a different way to go would be, when you ask for a mutable
copy, to REPLACE the tree already, and then to give you an iterator.
Then when you finalize things, if you get a different object, you
replace the tree again.  This could lead to redundant root
modifications, but this is probably okay.  I like this because then
you can have an iterator interface for children.  This would have this
kind of interface:

Iterator getMutableCopy(Iterator i);

Iterator finalize(Iterator i);

--> now you can actually finalize things and keeping things above them
    mutable.  and it shouldn't really change anyone else's
    view... yeah, this is pretty good.

also need an interface for cloning other objects... guess that can
still be the deep cloner.

- how are iterators implemented?  As a sequence of object identities,
  or as an index in the child list?  Need to be able to get the "next"
  object somehow.  especially when there could be multiple occurrences
  of a given object in a list - that's why you DO need to keep the
  index.  Then the thing will become stale upon addition/deletion.
  Could just keep track from root, with all of the indices along the
  way, yeah... and keep the version of root you're going off of, to
  warn for stale iterators.

- note that no stream constructs can really have iterators as fields...

things to be careful about:

- what about this toplevel root thing?

- will have to revisit the visitor implementation.  but probably not
very seriously, actually... the replacing visitor is at a low level.

--

- rethink the replacement in parent deal -- if we're replacing in
parent, should probably rewrite all the children stuff to be an array
that is indexed by a static int instead of indexing the actual object
in an sirinitstatement.

- the cloning stuff should all operate on iterators

- what about fields that are java objects?  how do we enforce that
they're immutable?  maybe we don't.  but in all of our IR classes, we
have a field in the base class that indicates whether or not it's
immutable.

- right, no sharing of components below the method level.  if it's the
same method, then it's cached to the same thing; otherwise there is no
sharing between methods.  this gets away from the cloning problems, i
think.

- checkout/in is at the level of a field/method, as well as pipeline/filter/etc

- naming was a speed optimization; it could be added for debugging
purposes.  so there's no naming going on in our model

- eventually generating different functions to access data in filters
that have different layouts.

- first hash the whole structure, then compare deeply

---------------------------------------------------------------------------


Immutable Iterators Spec
Version 1.0
---------------------------------------------------------------------------

OVERVIEW

This is the way that the immutable IR will work.  At some level, every
construct in the IR is immutable.  However, to simplify the model for
the programmer, we will allow a mutable programming interface to every
IR construct that is finer grained than the stream constructs--i.e.,
Filter, SplitJoin, Pipline, and FeedbackLoop (these will subsequently
be referred to as "stream constructs" or "stream structures".)
Memoization will be done at the level of stream constructs, which
requires a set of iterators for stream constructs, and names for all
transformations that are performed on stream constructs.

IMMUTABLE HIGH-LEVEL INTERFACE

Every stream construct is strictly immutable, meaning that a reference
to a given stream construct is guaranteed to always have the same set
of fields, methods, and child streams (if applicable.)  Thus, to
obtain a modified stream structure, one calls a mutator with an
iterator of the old stream construct, and obtains as the result an
iterator that points at the new stream construct.  This brings us to
iterators.

ITERATORS

The fundamental purpose of iterators is to add a context to a
reference to a given immutable stream construct.  That is, since
immutable constructs can be memoized, a given construct could have
multiple parents in the tree.  However, an iterator has a unique set
of parents that traces the position of the construct from the root to
the position of its instantiation.  Thus, iterators have parents for
advancing UP the tree, while the stream constructs themselves can have
methods for going DOWN the tree (which the iterators can mirror, of
course.)

It was our design decision to also make iterators completely
immutable.  Thus, iterators will not be "patched" when, for instance,
their component stream changes.  However, there is a mutable element
in our design, and that is the ROOT WRAPPER (called during discussion
a "streamit program".)

ROOT WRAPPER

There is one root wrapper per stream tree.  The identity of the
wrapper remains constant despite all additions / subtractions /
deletions / modifications to the tree, and it keeps track of the
current root of the tree.  In the event that the tree is merged with
another (e.g. added to a low level of a different tree) then the
low-level root wrapper will be annhilated in favor of the top-most
root wrapper.  The root wrapper keeps track of it's version, such that
any change to the tree results in new version tracking in the wrapper.

All iterators hold a reference to the root wrapper that identifies the
tree they are associated with.  Iterators also hold the version of the
tree to which they apply.  By comparing the version of the iterator
with that of the root wrapper, we can easily detect obsolete iterators
when they are accessed.  This is the fundamental purpose of the root
wrapper.

MODIFYING PIPELINES, SPLITJOINS, FEEDBACKLOOPS

The high-level stream constructs are strictly immutable.  This is to
preserve some semblance of a clean, immutable programming model in
cases where we think we can handle the complexity introduced as a
consequence in our IR programming.

MUTABLE LOW-LEVEL INTERFACE

We like the idea of an immutable IR the whole way through to tiny IR
elements like types and literals, but we think it'd complicate the
programming model too much to have strict immutability the whole way
down.  For instance, if you wanted to have both a handle on a for loop
and the statements that you're iterating over in that loop, the for
loop handle would go stale whenever you modified a component.  This
would introduce either a lot of bugs or a lot of complexity... e.g. it
makes it harder to write helper functions to do some sets of IR
construction.

So instead, all IR constructs have two stages:  they are created
MUTABLE and are changed into IMMUTABLE by a call to finalize() (or
setImmutable() or something.)  This is probably implemented with a
field in the base class of the IR constructs.  So newly-created IR
constructs are mutable.

But to modify existing constructs, you need to CLONE the stream
construct containing it.  Cloning will work as it currently does,
duplicating everything within a given scope.  The stream constructs
can be finalized() also to make everything they contain immutable.  We
can't think of a great way to implement this, but it will probably
just be with some kind of visitor that descends the whole way through
and makes everything immutable.

MEMOIZATION

For the sake of memoization, all stream constructs must be "committed"
to a global store once they have been finalized.  This is done with a
name for the transformation that was applied to the construct, as well
ast he identity of the original construct, and ALL PARAMETERS that
could have affected the transformation.  The memoizer will then use
this information to judge the "identity" of the committed construct,
and will replace all future instances of this identity with the one
being committed.  Thus it is critical that the name reflect the EXACT
transformation applied -- all transformations must be functional, and
not rely on global program state that could change between different
transformations of the same base class.

***************************************************************************

Immutable Iterators Spec
Version 0.9
---------------------------------------------------------------------------

The purpose of this architectural re-write is to provide a single framework
within which we will manage traversing and modifying the StreamIt tree.  The
main reason for doing this now is that we are having some major problems
with memory leaks (mp3 overflows 1.8 GB of RAM) which are difficult to track
down.  Immutable trees should alleviate any such problems.

Immutability

At the crux of the new system are immutable trees.  We haven't discussed in
detail how deep the immutability will be (SIRFilter, Method, statement, etc)
butit could be as deep as necessary.

Modifications mechanism

If the tree is immutable, then making changes will require making a new copy
of the tree.  This is not as bad as it seems, because we can still reference
the old, unmodified branches, so we only need to trace and rebuild the vine
leading to the root.  Note, that every modification will result in a
different (new) root!

Reusability

As an optimization, we want to introduce the idea of a 'type' and instance
of a SIRStream.  The purpose of this is that for example in a program with
many FIRFilters, we would like to only really keep one copy of the FIRFilter
code, and use it for all instances.

Iterators

In order to traverse the tree we will need a uniform framework of iterators.
These iterators will know how to traverse elements of their type.  (Details
are to come - I have some prototype interfaces that will need to be
implemented).  It will be up to the implementor's choice (guess Dave or
Gordo) whether iterators will be a single type that will be able to traverse
the entire tree, or if it will be many smaller types specialized toward a
particular tree node type (SIRFilter vs SIRSplitJoin).

An iterator points to a particular INSTANCE of a Stream.  One can request
from the iterator its parent, and it will return an iterator that points to
an INSTANCE of another stream (the actual instance parent of the original
iterator).

Memoization

Any optimization we implement should be applied to a particular instance of
a stream.  This includes even such things as propagating constants for
variable initialization.  Doing this in a naive way will lead to creating
multiple copies of the same stream type, when the same optimization is
applied to multiple instances.

For this purpose we will memoize results of an optimization on a stream
type.  Every new (modified) type will receive a new name.  The name will
reference the old type (by its name) and an optimization applied to it.
Note, that this means that parents of a node X will get new names when X is
modified, and that the new names will have to somehow specify that it was X
that was modified and how.
