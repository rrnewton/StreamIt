\section{Appendix: Detailed Example}
StreamIt is a high-level language designed to offer a simple and portable means of constructing programs as computational graphs. It is being developed here as a testbed for stream-based computing research and as a compiler geared towards parallelism-exposed architectures.

StreamIt takes on a slightly different approach than allowing arbitrary graphs to be constructed from nodes connected by channels. Instead nodes, or Filters as we call them, can be joined together by being contained in other Stream constructs such as Pipelines, SplitJoins, and FeedBackLoops. Further, these Pipelines, SplitJoins, and FeedBackLoops can in turned be contained in other Pipeline, SplitJoins, and FeedBackLoops to form complex hierarchies of Filters that interact to perform what the programmer desires. Together Filters, Pipelines, SplitJoins, and FeedBackLoops are referred to as Streams.

Streams use an input tape and output tape to communicate with other Streams, which is analogous to channels in a Phased Computational Graph. Pipelines allow Streams to be connected in series, one after the other, by connecting the output tape of a Stream to the input tape of the Stream immediately following it in the Pipeline. SplitJoins allow an input tape to be shared among several parallel Streams. The SplitJoin can use a programmer specifiable splitter and joiner to demultiplex the one input tape of the SplitJoin into the the many input tapes of the parallel Streams and then multiplex the output from the many output tapes of the parallel Streams into one output tape of the SplitJoin. Finally, FeedBackLoops allow loops in the stream graph. A FeedBackLoop has a main forward Stream and feedback Stream which data cycles through an the way around. A programmer specifiable splitter selects which data from the output tape of the main Stream is to be fed into the input tape of the feedback Stream and which date is to leave through the FeedBackLoops output tape. Likewise, the specifiable splitter selects whether data from the input tape of the FeedBackLoop or the output tape of feedback Stream is fed into the input tape of the forward Stream.

StreamIt supports a sizable subset of the Phased Computational Program model. StreamIt is still under development and more time has been given to the correctness and efficiency of the common cases than developing a fully general framework. Both the initial and steady-state epochs are supported. Further, both epochs support arbitrary phases.
\begin{figure}[t]
\begin{verbatim}
float->float filter FIR (init N, int LENGTH) {
   float[N] weights;

   init {
      calcWeights();
      for (int i=0; i<N; i++) {
         doFIR(i); //Queue doFIR(i) for init
      }
      exec doFIR(N); //Queue doFIR(N) for steady-state
    }

    work doFIR (int K) push 1 pop 1 peek K {
       float val = 0;
       for (int i=0; i<K; i++) {
          val += weights[i] * peek(i);
       }
       push(val);
       pop();
    }
}
\end{verbatim}
\caption{Fir Code
\protect\label{fig:fir}}
\end{figure}

Figure \ref{fig:fir} is a fairly typical sample of Filter code. Calling a work function, such as ``doFIR(i)'' enqueues that execution for an init phase, while calling a work function following the token exec, such as ``exec doFIR(N)'', enqueues that execution for a steady-state phase. Another important piece of information is ``push 1 pop 1 peek K'' specifies that U(out,steady-state,p)=1, O(in,steady-state,p)=1, E(in,steady-state,p)=K$_p$, where in, out, and K$_p$ are the input channel, output channel, and K's value during phase p, respectively. Let us, for the sake of this example, say N=2. The final result is that U and O always equal 1 but E takes on the following values:
\begin{align}
\mt{E}(in,init,0)&=1\nonumber\\
\mt{E}(in,init,1)&=1\nonumber\\
\mt{E}(in,steady,0)&=2\nonumber
\end{align}

To make a simple example lets consider the graph of a FIR Filter (denoted fir) connected to the output of a filter that produces [1,2] each iteration\footnote{Another way of saying that it pushes 1 then 2 out of its output.}. From now on let us denote the channel between them as in and the output channel of fir as c. Further, let fir's weights=[1,2]. Let us consider all the equations in figures \ref{fig:pcptosare2} and \ref{fig:pcptosare3} in turn.
\begin{itemize}
\item Equation \ref{i2ibuf} does not contribute, since A(c)=0.
\item Equation \ref{iwrite2ibuf}:
\begin{align}
\mt{IBUF}_c(0)&=\mt{IWRITE}_{c,0}(0)\label{ex0}\\
\mt{IBUF}_c(1)&=\mt{IWRITE}_{c,1}(0)\nonumber
\end{align}
\item Equation \ref{iread2iwrite}:
\begin{align}
\mt{IWRITE}_{c,0}(0)&=(\mt{W}(fir,init,0)([\mt{IREAD}_{in,0}(*)]))[0][0]\nonumber\\
&=(\mt{W}(fir,init,0)([1]))[0][0]\nonumber\\
&=([[1]])[0][0]=1\label{ex1}\\
\mt{IWRITE}_{c,1}(0)&=(\mt{W}(fir,init,1)([\mt{IREAD}_{in,1}](*)))[0][0]\nonumber\\
&=(\mt{W}(fir,init,1)([2]))[0][0]\nonumber\\
&=([[2*1]])[0][0]=2\nonumber
\end{align}
Therefore, by equations \ref{ex0}
\begin{align}
\mt{IBUF}_c(0)&=1\label{ex2}\\
\mt{IBUF}_c(1)&=2\nonumber
\end{align}
\item Equation \ref{sread2swrite}:
\begin{align}
SWRITE_{c,0}(i,j,0)&=(\mt{W}(fir,steady,0)([\mt{SREAD}_{in,0}(i,j,\*)]))[0][0]\nonumber\\
&=(\mt{W}(fir,steady,0)([[1,2]]))[0][0]\label{ex3}\\
&=([1*1+2*2]))[0][0]=5\nonumber
\end{align}
\item Equation \ref{swrite2sbuf}:
\begin{align}
\mt{SBUF}_c(i,0)=SWRITE_{c,0}(i,0,0)\label{ex4}
\end{align}
Therefore, by equation \ref{ex3}
\begin{align}
\mt{SBUF}_c(i,0)=5\label{ex5}
\end{align}
\item Equation \ref{ibuf2iread}:
\begin{align}
IREAD_{c,0}(0)&=\mt{IBUF}_c(\mt{PartialRead}(c,init,0)+0)\nonumber\\
&=\mt{IBUF}_c(0)\label{ex6}\\
IREAD_{c,1}(0)&=\mt{IBUF}_c(\mt{PartialRead}(c,init,1)+0)\nonumber\\
&=\mt{IBUF}_c(1)\nonumber
\end{align}
Therefore, by equations \ref{ex2}
\begin{align}
\mt{IREAD}_c(0)&=1\label{ex7}\\
\mt{IREAD}_c(1)&=2\nonumber
\end{align}
\item Equation \ref{sbuf2iread}: Impossible since it would have to be the case that $i\in D_{IREAD_{c,p}}$, which implies $i<2$, and $i>|D_{IBUF_c}|=2$.
\item Equation \ref{ibuf2sread}: Impossible since the lowest value ReadIndex can take on is TotalRead(n,c,init)=2, so it can never be the case that ReadIndex(n,c,p,i,j,k)$\in D_{IBUF_c}$
\item Equation \ref{sbuf2sread0} and \ref{sbuf2sread1}: Period(c)=1\\
Therefore, by equation \ref{ex5}
\begin{align}
SREAD_{c,0}(i,j,k)=\mt{SBUF}_c(i,0)=5
\end{align}
\end{itemize}
