\newcommand{\la}{$\leftarrow$}
\newcommand{\IND}{\begin{ALC@g}}
\newcommand{\UND}{\end{ALC@g}}
\newcommand{\tup}[2]{\langle{#1}, {#2}\rangle}

\section{Stream Dependence Function}

In this section, we describe our model of computation and define the
stream dependence function, $\sdep$.

Our model of computation is Cyclo-Static Dataflow~\cite{BELP96}.  In
this model, the stream graph is a directed graph where nodes represent
actors and edges represent FIFO communication channels.  Each actor
has a set of execution steps, or phases, which consume some items from
the input channels and produce some items on the output channels.  The
number and ordering of phases is known at compile time, and their
execution is cyclic (after executing the last phase, the first phase
is executed again).  Also, for each phase, the number of items
produced and consumed from the channels is fixed and known at compile
time.
%We also permit actors to ``peek'' at items that are not
%consumed from the channel, and the peek amount is known at compile
%time (note that peeking is not part of CSDF).
Cyclo-Static Dataflow is a generalization of Synchronous
Dataflow~\cite{LM87-i}, which requires each actor to have only a
single phase.

An exection $\phi$ of a dataflow graph is an ordered sequence of actor
firings.  Each firing represents the execution of a single phase of
the actor.  Let $\phi[i]$ denote the $i$th actor appearing in
execution $\phi$, and let $|\phi \wedge A|$ denote the number of times
that actor $A$ appears in $\phi$.  An execution is legal if the
dataflow requirements are respected; that is, for all $i$, the
sequential firing of actors $\phi[0]$ through $\phi[i-1]$ leaves
enough items on the communication channels for $\phi[i]$ to fire its
next phase atomically.  Let $\Phi$ denote the set of legal executions.
Note that while $\Phi$ is an infinite set, each $\phi \in \Phi$ is a
finite sequence.

The stream dependence function, $\sdep$, describes the dependences
between actor firings in the graph.  Informally, $\sdepf{A}{B}(n)$
represents the minimum number of times that actor $A$ must execute to
make it possible for actor $B$ to execute $n$ times.  This dependence
is meaningful only if there is a directed path in the stream graph
from $A$ to $B$; otherwise, $\sdep$ will have a value of zero.
Because the I/O rates of each actor in the stream graph are known at
compile time, $\sdep$ is also a static relation.  The following is a
formal definition of $\sdep$ using the notations from above:
\begin{definition}(SDEP)
\begin{center}
$\sdepf{A}{B}(n)~~ = ~~\mbox{MIN}~~|\phi \wedge A|$ \\
~~~~~~~~~~~~~\raisebox{5pt}[0pt]{$~_{\phi \in \Phi, |\phi \wedge B| = n}$}
\label{eq:sdepdef}
\end{center}
\end{definition}
This equation reads: over all legal executions in which $B$ fires $n$
times, $\sdepf{A}{B}(n)$ is the minimum number of times that $A$
fires.  An example of $\sdep$ for the stream graph in
Figure~\ref{fig:sdep-rates} appears in Figure~\ref{fig:sdep1}.

\begin{figure}[t]
\begin{center}
\psfig{figure=sdep-example-rates3.eps,height=1.5in}
\caption{{\small Example stream graph. Nodes are annotated with their
I/O rates; nodes A and E have two phases. \protect\label{fig:sdep-rates}}}
\end{center}
\vspace{-12pt}
\end{figure}

\begin{figure*}[t]
\begin{center}
\psfig{figure=sdep-example3.eps,width=7in}
\caption{\small Example \figsdep\ calculation for stream graph in
Figure~\ref{fig:sdep-rates}.  The stream graphs illustrate a steady
state cycle of a ``pull schedule''; execution proceeds from left to
right, and channels are annotated with the number of items present.
Because a pull schedule is as fine-grained as possible,
$\figsdepf{X}{Y}(n)$ can be calculated as the number of times that $X$
executes before the $n$th execution of $Y$.
\protect\label{fig:sdep1}}
\end{center}
\vspace{-12pt}
\end{figure*}

\section{Calculating SDEP}

It is straightforward to calculate $\sdepf{A}{B}(n)$ via a
fine-grained simulation of the stream graph.  Our approach is to
construct an execution $\phi$ that provides the minimum value of
$|\phi \wedge A|$ that is selected in Definition~\ref{eq:sdepdef}.  We
construct $\phi$ by simulating the stream graph's execution of a
``pull schedule'' with respect to actor $B$.

\begin{center}
\framebox{\parbox{3.25in}{
\mbox{} \textsc{Algorithm 1.} {\it (Pull scheduling)} \vspace{6pt}\\
\mbox{} ~~~~// {\it Returns a pull schedule for $n$ executions of $X$} \\
\mbox{} ~~~~{\bf pullSchedule}($X$, $n$) \{\\
\mbox{} ~~~~~~~$\phi = \{ \}$ \\
\mbox{} ~~~~~~~{\bf for} $i$ = 1 to $n$ \{ \\
\mbox{} ~~~~~~~~~~{\bf for all} input channels $c_i$ of $X$ \\
\mbox{} ~~~~~~~~~~~~~{\bf while} $X$ needs more items on $c_i$ for next phase \\
\mbox{} ~~~~~~~~~~~~~~~~$\phi = \phi $ o {\bf pullSchedule}({\bf source}($c_i$)) \\
\mbox{} ~~~~~~~~~~{\bf simulateCurrentPhase}($X$) \\
\mbox{} ~~~~~~~~~~$\phi = \phi~\circ~X$ \\
\mbox{} ~~~~~~~{\bf end for} \\
\mbox{} ~~~~~~~return $\phi$ \\
\mbox{} ~~~~\}
}}
\end{center}
Intuitively, a pull schedule for $X$ is one that executes other nodes
as few times as possible for each firing of $X$.  This is achieved by
calculating the demand for data items on the input channels of $X$,
and then propagating the demand back through the stream graph via pull
scheduling of the actors connected to $X$.  Pull scheduling results in
a fine-grained interleaving of actor firings.  The following theorem
allows us to use a pull schedule to calculate the $\sdep$ function.
\begin{theorem} 
\[
\sdepf{A}{B}(n) = |{\bf pullSchedule}(B, n) \wedge A|
\]
\end{theorem}
\begin{proof}
By construction, ${\bf pullSchedule}(B, n)$ executes each node in the
graph as few times as possible for $B$ to fire $n$ times.  Thus, there
is no execution containing $n$ executions of $B$ where $A$ executes
fewer times.  The theorem follows from the definition of $\sdep$.
\end{proof}

Some example $\sdep$ calculations appear in Figure~\ref{fig:sdep1}.
The results are summarized in the following table:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
$n$ & $\sdepf{A}{E}(n)$ & $\sdepf{B}{E}(n)$ \\
\hline \hline
1 & 5 & 0 \\ \hline
2 & 5 & 2 \\ \hline
3 & 5 & 2 \\ \hline
4 & 6 & 3 \\ \hline
\end{tabular}
\end{center}
Note that $\sdep$ is highly non-linear due to mis-matching I/O rates
in the stream graph.  However, for longer execution traces, there is a
pattern in the marginal growth of $\sdep$ ({\it i.e.,} in $\sdep(n) -
\sdep(n-1)$); this quantity follows a cyclic pattern and has the same
periodicity as the steady state of the stream graph.  A steady state
${\cal S}$ is an execution that does not change the buffering in the
channels; the number of items on each channel after the execution is
the same as it was before the execution.  The execution simulated in
Figure~\ref{fig:sdep1} is a steady state, meaning that additional
entries of the pull schedule will repeat the pattern given in the
figure.  Thus, $\sdep$ will also grow in the same pattern, and we can
calculate $\sdep$ for $n > 4$ as follows\footnote{Note that for any
two actors $X$ and $Y$, $\sdepf{X}{Y}(0) = 0$}:
\begin{equation*}
\begin{array}{l}
\mbox{} \hspace{-5pt} \sdepf{A}{E}(n) = \\ 
~~~~~|{\cal S} \wedge A| * \floor{n-1}{|{\cal S} \wedge E|} + \sdepf{A}{E}(n-1~\mt{mod}~|{\cal S} \wedge E|) \vspace{3pt} \\
\mbox{} \hspace{-5pt} \sdepf{B}{E}(n) = \\
~~~~~|{\cal S} \wedge B| * \floor{n-1}{|{\cal S} \wedge E|} + \sdepf{B}{E}(n-1~\mt{mod}~|{\cal S} \wedge E|)
\end{array}
\end{equation*}
where ${\cal S}$ is a steady state execution.  In this example,
$|{\cal S} \wedge A| = 6$, $|{\cal S} \wedge B| = 3$, and $|{\cal S}
\wedge E| = 4$.  There are well-known techniques for computing steady
state schedules~\cite{LM87-i}.

Thus, to calculate $\sdepf{X}{Y}(n)$, it is not necessary to simulate
a pull schedule for $n$ iterations of $Y$ as described in Algorithm 1.
Instead, one can simulate $|{\cal S} \wedge Y|$ iterations as a
pre-processing step and answer all future $\sdep$ queries in constant
time.  In addition, the pull schedule for $Y$ can be reused to
calculate $\sdep$ from $Y$ to any other actor ({\it e.g.,}
$\sdepf{W}{Y}$ in addition to $\sdepf{X}{Y}$).

However, note that the pull schedule for $Y$ can NOT be used to
calculate $\sdep$ from any actor other than $Y$ ({\it e.g.,}
$\sdepf{W}{X}$).  The guarantee provided by ${\bf pullSchedule}(X, n)$
is only with respect to the base actor $X$. For other pairs of actors
in the graph, one actor might execute more than necessary for $n$
executions of the other.  For example, consider what happens if we
calculate $\sdepf{A}{B}$ using the schedule in Figure~\ref{fig:sdep1}
(which is a pull schedule for $E$).  In the schedule, $A$ executes 4
times before the first firing of $B$, so we would conclude that
$\sdepf{A}{B}(1) = 4$.  However, this is incorrect; since $B$ could
have fired after only 2 executions of $A$, the correct value is
$\sdepf{A}{B} = 2$.  Thus, to calculate $\sdepf{X}{Y}$, it is
essential to calculate ${\bf pullSchedule}(Y, |{\cal S} \wedge Y|)$,
that is, a steady state cycle of the pull schedule with respect to
$Y$.

%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else 
%%     countA = 0
%%     countB = 0
%%     do {
%%       child <- most downstream actor of G that can fire
%%       simulatePhase(child)
%%       if child = A then
%%         countA++;
%%       else if child = B then
%%         countB++;
%%       endif
%%     } loop until (countB = n)
%%   endif
%%   return countA
%% }
%% \end{verbatim}}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   countA = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       SDEP = SDEP o countA
%%     endif
%%   } loop until |SDEP| = steady(B)
%%   return SDEP
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}

%% \begin{figure}[t]
%% {\scriptsize
%% \begin{verbatim}
%% int SDEP_{A<-B} (n) {
%%   if (n <= 0) || (no path from A to B in G) then
%%     return 0
%%   else
%%     cycles = floor(steady(B) / (n-1))
%%     return cycles * steady(A) + steadySDEP_{A<-B}[(n-1) mod steady(B)]
%%   endif
%% }

%% global targetCount;
%% global targetActor;
%% int[] steadySDEP_{A<-B} {
%%   SDEP = { }
%%   targetActor = A
%%   targetCount = 0
%%   for i = 1 to steady(B)
%%     pullSchedule(B)
%%     SDEP = SDEP o { countTarget }
%%   endfor
%%   return SDEP
%% }

%% pullSchedule(X) {
%%   for all input channels c_i of X
%%     while X needs more items on c_i for next phase
%%       pullSchedule(source(c_i))
%%   simulatePhase(X)
%%   if X=targetActor then
%%     targetCount++
%%   endif
%% }
%% \end{verbatim}}
%% \vspace{-12pt}
%% \caption{\small Algorithm for computing $\figsdepf{A}{B}$ in a
%% dataflow graph $G$.  Because $\figsdep$ information is cyclic, a
%% simulation of a single steady state (the $\mt{steadySDEP}$ table) is
%% sufficient to answer all $\figsdep$
%% queries. \protect\label{fig:sdep1}}
%% \end{figure}

%% \todo{Correct pseudocode to handle initialization.}

%% reference code to borrow from to get the init/steady phases right:

%% int SDEP_{A<-B} (n) {
%%   if no path from A to B in G then
%%     return 0
%%   else
%%     <sdepInit, sdepSteady> = sdepTable(A,B)
%%     if n<|sdepInit| then
%%       return sdepInit[n]
%%     else
%%       nAfterInit = n - |sdepInit|
%%       cycles = floor(steady(B) / nAfterInit)
%%       return cycles * steady(A) + sdepSteady[nAfterInit mod steady(B)]
%%     endif
%%   endif
%% }

%% <int[], int[]> sdepTable(A,B) {
%%   sdepInit = { 0 }
%%   sdepSteady = { }
%%   countA = 0
%%   countB = 0
%%   do {
%%     child <- most downstream actor of G that can fire
%%     simulatePhase(child)
%%     if child = A then
%%       countA++
%%     else if child = B then
%%       if (countB<init(B) || countA<init(A)) then
%%         sdepInit = sdepInit o countA
%%       else
%%         sdepSteady = sdepSteady o countA
%%       endif
%%       countB++
%%     endif
%%   } loop until |sdepSteady| = steady(B)
%%   return <sdepInit, sdepSteady>
%% }
