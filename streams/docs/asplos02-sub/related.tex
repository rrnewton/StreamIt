\section{Related Work}
\label{sec:related}

The Transputer architecture~\cite{transputer88} is an array of
processors, where neighboring processors are connected with unbuffered
point-to-point channels.  The Transputer does not include a separate
communication switch, and the processor must get involved to route
messages.  The programming language used for the Transputer is Occam
\cite{occammanual}: a streaming language similar to CSP
\cite{Hoare78}.  However, unlike StreamIt filters, Occam concurrent
processes are not statically load-balanced, scheduled and bound to a
processor. Occam processes are run off a very efficient runtime
scheduler implemented in microcode~\cite{may87communicating}.

DSPL is a language with simple filters interconnected in a flat acyclic
graph using unbuffered channels~\cite{Thiel93}.  Unlike the Occam
compiler for the Transputer, the DSPL compiler automatically maps the
graph into the available resources of the Transputer. The DSPL language
does not expose a cyclic schedule, thus the compiler models the
possible executions of each filter to determine the possible cost of
execution and the volume of communication. It uses a search technique
to map multiple filters onto a single processor for load balancing and
communication reduction. 

\begin{figure}
\begin{minipage}{3.2in}
\centering
\psfig{figure=speedup-diagram.eps,width=3.2in}
\caption{Speedup due to load balancing, normalized to original performance.
\protect\label{fig:opt-diagram}}
\end{minipage}
\hspace{0.1in}
\begin{minipage}{3.2in}
\centering
\psfig{figure=utilization-diagram.eps,width=3.2in}
\caption{Utilization of a tile after load balancing, normalized to original utilization.\protect\label{fig:utilization-diagram}}
\end{minipage}
\end{figure}

The Imagine architecture is specifically designed for the streaming
application domain~\cite{rixner98bandwidthefficient}.  It operates on
streams by applying a computation kernel to multiple data items off
the stream register file.  The compute kernels are written in Kernel-C
while the applications stitching the kernels are written in Stream-C.
Unlike StreamIt, with Imagine the user has to manually extract the
computation kernels that fit the machine resources in order to get
good steady state performance for the execution of the
kernel~\cite{kapasi:2001:ss}.  On the other hand, StreamIt uses
fission and fusion transformations to create load-balanced computation
units and filters are replicated to create more data parallelism when
needed.  Furthermore, the StreamIt compiler is able to use global
knowledge of the program for layout and transformations at
compile-time while Stream-C interprets each basic block at runtime and
performs local optimizations such as stream register allocation in
order to map the current set of stream computations onto Imagine.

The iWarp system \cite{iwarp} is a scalable multiprocessor with
configurable communication between nodes.  In iWarp, one can set up a
few FIFO channels for communicating between non-neighboring
nodes. However, reconfiguring the communication channels is more
coarse-grained and has a higher cost than on Raw, where each cycle can
be used to route items to a different location~\cite{scalaroperands}.
ASSIGN \cite{assign} is a tool for building large-scale applications
on multiprocessors, especially iWarp.  ASSIGN starts with a
coarse-grained flow graph that is written as fragments of C code.
Like StreamIt, it performs partitioning, placement, and routing of the
nodes in the graph.  However, ASSIGN is implemented as a runtime
system instead of a full language and compiler such as StreamIt.
Consequently, it has fewer opportunities for global transformations
such as fission and reordering.

SCORE (Stream Computations Organized for Reconfigurable Execution) is
a stream-oriented computational model for virtualizing the resources
of a reconfigurable architecture~\cite{score}.  Like StreamIt, SCORE
aims to improve portability across reconfigurable machines, but it
takes a dynamic approach of time-multiplexing computations (divided
into ``compute pages'') from within the operating system, rather than
statically scheduling an application within the compiler.

Ptolemy~\cite{ptolemyoverview} is a simulation environment for
heterogeneous embedded systems, including the domain of Synchronous
Dataflow (SDF) that is similiar to the static-rate stream graphs of
StreamIt.  While there are many well-established scheduling techniques
for SDF~\cite{leesdf}, the round-robin nodes in our stream graph
require the more general model of Cyclo-Static Dataflow
(CSDF)~\cite{BELP96} for which there are fewer results.  Even CSDF
does not have a notion of an initialization phase, filters that peek,
or a dynamic messaging system as supported in StreamIt.  In all, the
StreamIt compiler differs from Ptolemy in its focus on optimized code
generation for the nodes in the graph, rather than high-level modeling
and design.

Proebsting and Watterson \cite{pro96} present a filter fusion
algorithm that interleaves the control flow graphs of adjacent nodes.
However, they assume that nodes communicate via synchronous {\tt get}
and {\tt put} operations; StreamIt's asynchronous peek operations and
implicit buffer management fall outside the scope of their model.

A large number of programming languages have included a concept of a
stream; see \cite{survey97} for a survey.  Synchronous languages such
as LUSTRE~\cite{lustre}, Esterel~\cite{esterel92}, and
Signal~\cite{signal} also target the embedded domain, but they are
more control-oriented than StreamIt and are not aggressively optimized
for performance.  Sisal (Stream and Iteration in a Single Assignment
Language) is a high-performance, implicitly parallel functional
language~\cite{sisal}.  The Distributed Optimizing Sisal
Compiler~\cite{sisal} considers compiling Sisal to distributed memory
machines, although it is implemented as a coarse-grained master/slave
runtime system instead of a fine-grained static schedule.

