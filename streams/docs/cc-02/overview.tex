% \begin{figure}
% \vspace{-6pt}
% \begin{minipage}{2.175in}
% \psfig{figure=fir-streamit-left.eps,width=162.35pt}
% \end{minipage}
% \hspace{0.2in}
% \begin{minipage}{2.4in}
% \psfig{figure=fir-streamit-right.eps,width=102.35pt}
% \vspace{0.55in}
% \caption{\protect\small An FIR filter in StreamIt.
% \protect\label{fig:firstreamit}}
% \end{minipage}
% \vspace{-12pt}
% \end{figure}

\section{Language Overview}
\label{sec:overview}

StreamIt includes stream-specific abstractions and representations
that are designed to improve programmer productivity for the domain of
programs described above.  In this paper, we present StreamIt in legal
Java syntax for ease of presentation\footnote{However, for the sake of
brevity, the code fragments in this paper are sometimes lacking
modifiers or methods that would be needed to make them strictly legal
Java.}.  Though this syntax can express the fundamental ideas of
StreamIt, in the longer term we plan to develop a cleaner and more
abstract syntax that is designed specifically for stream programs.

\begin{figure}[t]
\begin{minipage}{2.05in}
\vspace{-6pt}
\psfig{figure=fir-streamit.eps,width=176.47pt}
\vspace{-24pt}
\caption{\protect\small An FIR filter in StreamIt.~~~~~
\protect\label{fig:firstreamit}}
\end{minipage}
\begin{minipage}{2.75in}
\centering
\vspace{10pt}
\psfig{figure=basic-pipeline.eps,width=1.8in}

(a) A Pipeline. \\
\vspace{10pt}
\psfig{figure=basic-splitjoin.eps,width=1.8in}

(b) A SplitJoin. \\
\vspace{10pt}
\psfig{figure=basic-feedback.eps,width=1.8in}

(c) A FeedbackLoop. \\
\caption{\protect\small Stream structures supported by StreamIt.
\protect\label{fig:structuresp}
}
\end{minipage}
\vspace{-18pt}
\end{figure}

\subsection{Filters}

The basic unit of computation in StreamIt is the {\tt Filter}.  An
example of a Filter is the {\tt FIRFilter} (see Figure
\ref{fig:firstreamit}), a component of the software radio shown in
Figure \ref{fig:radiodiagram}.  The central aspect of a Filter is the
{\tt work} function, which describes the filter's most fine grained
execution step in the steady state.  Within the {\tt work} function, a
filter can communicate with neighboring blocks using the {\tt input}
and {\tt output} channels, which are FIFO queues declared as fields in
the Filter base class.  These high-volume channels support the three
intuitive operations: 1) {\bf pop()} removes an item from the end of
the channel and returns its value, 2) {\bf peek($i$)} returns the
value of the item $i$ spaces from the end of the channel without
removing it, and 3) {\bf push($x$)} writes $x$ to the front of the
channel.  The argument $x$ is passed by value; if it is an object, a
separate copy is enqueued on the channel.
% \begin{enumerate}
% \item {\tt pop()} removes an item from the end of the channel and
% returns its value.
% \item {\tt peek($i$)} returns the value of the item $i$ spaces from
% the end of the channel without removing it.
% \item {\tt push($x$)} writes $x$ to the front of the channel.  The
% argument $x$ is passed by value; if it is an object, a separate copy
% is enqueued on the channel.
% \end{enumerate}

A major restriction of StreamIt 1.0 is that it requires filters to
have static input and output rates.  That is, the number of items
peeked, popped, and pushed by each filter must be constant from one
invocation of the {\tt work} function to the next.  In fact, as
described below, the input and output rates must be declared in the
Filter's {\tt init} function.  If a filter violates the declared
rates, StreamIt throws a runtime error and the subsequent behavior of
the program is undefined. We plan to support dynamically changing
rates in a future version of StreamIt.

Each {\tt Filter} contains an {\tt init} function that is called at
initialization time.  The {\tt init} function serves two purposes.
Firstly, it is for the user to establish the initial state of the
Filter.  For example, the FIRFilter records {\tt weights}, the
coefficients that it should use for filtering.  A filter can also
push, pop, and peek items from within the {\tt init} function if it
needs to set up some initial state on its channels, although this
usually is not necessary.  A user should instantiate a filter by using
its constructor, and the {\tt init} function will be called implicitly
with the same arguments that were passed to the
constructor{\footnote{This design might seem unnatural, but it is
necessary to allow inlining (Section
\ref{sec:connecting}) and re-initialization (Section \ref{sec:reinit})
within a Java-based syntax.}}.

The second purpose of the {\tt init} function is to specify the
filter's I/O types and data rates to the StreamIt compiler.  The types
are specified with calls to {\tt setInput} and {\tt setOutput}, while
the rates are specified with calls to {\tt setPush}, {\tt setPop}, and
{\tt setPeek}.  The {\tt setPeek} call can be ommitted if the peek
count is the same as the pop count.

\begin{figure}[t]
\vspace{-6pt}
\begin{minipage}{2.4in}
\psfig{figure=fir-proc.eps,width=194.14pt}
\vspace{-12pt}
\caption{\protect\small An optimized FIR filter in a procedural
   language.  A complicated loop nest is required to avoid mod
   functions and to use memory efficiently, and the structure of the
   loops depends on the data rates (e.g., BLOCK\_SIZE) within the
   stream.  An actual implementation might inline the calls to {\tt step}.
\protect\label{fig:firprocedural}}
\end{minipage}
\hspace{0.3in}
\vspace{-12pt}
\begin{minipage}{2in}
\psfig{figure=fir-object.eps,width=165.88pt}
\caption{\protect\small An FIR filter in an object oriented language.
A ``pull model'' is used by each filter object to retrieve a chunk of
data from its source, and straight-line code connects one filter to
another.
\protect\label{fig:firobject}}
\end{minipage}
\vspace{-6pt}
\end{figure}

\subsubsection{Rationale}
\label{sec:oo-rat}

StreamIt's representation of a filter is an improvement over
general-purpose languages.  In a procedural language, the analog of a
filter is a block of statements in a complicated loop nest (see Figure
\ref{fig:firprocedural}).  This representation is unnatural for expressing
the feedback and parallelism that is inherent in streaming systems.
Also, there is no clear abstraction barrier between one filter and
another, and high-volume stream processing is muddled with global
variables and control flow.  The loop nest must be re-arranged if the
input or output ratios of a filter changes, and scheduling
optimizations further inhibit the readability of the code.  In
contrast, StreamIt places the filter in its own independent unit,
making explicit the parallelism and inter-filter communication while
hiding the grungy details of scheduling and optimization from the
programmer.

One could also use an object-oriented language to implement a stream
abstraction (see Figure \ref{fig:firobject}).  This avoids some of the
problems associated with a procedural loop nest, but the programming
model is again complicated by efficiency concerns.  That is, a runtime
library usually exectutes filters according to a pull model, where a
filter operates on a block of data that it retrieves from the input
channel.  The block size is often optimized for the cache size of a
given architecture, which hampers portability.  Moreover, operating on
large-grained blocks obscures the fundamental fine-grained algorithm
that is visible in a StreamIt filter.  Thus, the absence of a runtime
model in favor of automated scheduling and optimization again
distinguishes StreamIt.

\subsection{Connecting Filters}
\label{sec:connecting}

\begin{figure}[t]
\begin{minipage}{2.175in}
% \psfig{figure=fft-streamit.eps,width=165.88pt}
% \vspace{-18pt}
% \caption{\protect\small A Fast Fourier Transform (FFT) in StreamIt.
% \protect\label{fig:fft}}
% \end{minipage}
\psfig{figure=echo.eps,width=169.41pt}
\vspace{-18pt}
\caption{\protect\small An echo effect in StreamIt.
\protect\label{fig:echo}}
\end{minipage}
\hspace{0.2in}
\begin{minipage}{2.4in}
\psfig{figure=fib-streamit.eps,width=180pt}
\vspace{-18pt}
\caption{\protect\small A FeedbackLoop version of Fibonnacci.
\protect\label{fig:feed}}
\end{minipage}
\vspace{-12pt}
\end{figure}

StreamIt provides three constructs for composing filters into a
communicating network: Pipeline, SplitJoin, and FeedbackLoop (see
Figure~\ref{fig:structuresp}).  Each structure specifies a pre-defined
way of connecting filters into a single-input, single-output block,
which we will henceforth refer to as a ``stream''.  That is, a stream
is any instance of a Filter, Pipeline, SplitJoin, or FeedbackLoop.
% Generally, a Pipeline is for building a sequence of streams, a
% SplitJoin is for running streams in parallel, and a FeedbackLoop is
%for introducing a loop in the stream graph.  
Every StreamIt program is a hierarchical composition of these stream
structures.

The {\bf Pipeline} construct is for building a sequence of streams.
Like a Filter, a Pipeline has an {\tt init} function that is called
upon its instantiation.  Within {\tt init}, component streams are
added to the Pipeline via successive calls to {\tt add}.  For example,
in the AudioEcho in Figure~\ref{fig:echo}, the {\tt init} function
adds four streams to the Pipeline: an AudioSource, an EchoEffect, an
Adder, and a Speaker.  This sequence of statements automatically
connects these four streams in the order specified.  Thus, there is no
{\tt work} function in a Pipeline, as the component streams fully
specify the behavior.  The channel types and data rates are also
implicit from the connections.

The input and output channels of the Pipeline itself are connected to
the first and last component streams, respectively.  Thus, a Pipeline
can be embedded in another stream construct, and the channels of the
first and last streams are implicitly connected to the Pipeline's
neighbors in the parent construct.  Alternatively, if a Pipeline
consumes no items from its input and produces no items to its output
(as is the case with AudioEcho), then the Pipeline can be run as an
independent unit--a toplevel StreamIt program.  Any Pipeline,
SplitJoin, or FeedbackLoop that has consumes no input and produces no
output is a valid toplevel program in StreamIt.

% Of course, there are a number of semantic restrictions on the
% construction of Pipelines.  For each pair of streams that is
% connected, the output type of the first stream must match the input
% type of the next.  Also, there must be non-zero production and
% consumption rates along the inner connections of a Pipeline, such that
% data flows through the entire pipe.  We omit a full discussion of
% semantic checking in StreamIt due to lack of space.

% Each of the stream constructs can either be executed on its own, or
% embedded in an enclosing stream structure.  The AudioEcho must execute
% independently, since the first component consumes no items
% and the last component produces no items.  However, the EchoEffect must
% be used as a component, since the first stream inputs items and the
% last stream outputs items.  When a stream is embedded in another construct,
% the first and last components of the stream are implicitly connected to the
% stream's neighbors in the parent construct.
%
The {\bf SplitJoin} construct is used to specify independent parallel
streams that diverge from a common {\it splitter} and merge into a
common {\it joiner}.  As in a Pipeline, the components of a SplitJoin
are specified with successive calls to {\tt add} from the {\tt init}
function.  For example, the EchoEffect in Figure~\ref{fig:echo} adds
two streams that run in parallel, each of which is a Delay filter.

The splitter specifies how items from the input of the SplitJoin are
distributed to the parallel components.  For simplicity, we allow only
compiler-defined splitters, of which there are three types: 1) {\bf
Duplicate}, which replicates each data item and sends a copy to each
parallel stream, 2) {\bf RoundRobin($i_1$, $i_2$, $\dots$, $i_k)$},
which sends the first $i_1$ data items to parallel stream 1, the next
$i_2$ data items to parallel stream 2, and so on, and 3) {\bf Null},
which means that none of the parallel components require any input,
and there are no input items to split.  If the weights are ommitted
from a RoundRobin, then they are assumed to be equal to one for each
stream.  Note that RoundRobin can function as an exclusive selector if
one or more of the weights are zero.
% \begin{enumerate}
% \item {\tt Duplicate}, which replicates each data item and sends a copy to each
% parallel stream.
% \item {\tt RoundRobin($i_1$, $i_2$, $\dots$, $i_k)$},
% which sends the first $i_1$ data items to parallel stream 1, the next
% $i_2$ data items to parallel stream 2, and so on.  If the weights are
% ommitted, then they are assumed to be equal to one for each stream.  Note
% that RoundRobin can function as an exclusive selector if one or more of the
% weights are zero.
% \item {\tt Null}, which means that none of the parallel components require
% any input, and there are no input items to split.
% \end{enumerate}

Likewise, the joiner is used to indicate how the outputs of the
parallel streams should be interleaved on the output channel of the
SplitJoin.  There are two kinds of joiners: 1) {\bf RoundRobin}, whose
function is analogous to a RoundRobin splitter, and 2) {\bf Null},
which means that none of the parallel components produce any output,
and there are no output items to join.
% \begin{enumerate}
% \item {\tt RoundRobin($i_1$, $i_2$, $\dots$, $i_k)$}, whose function is analogous to a RoundRobin splitter.
% \item {\tt Null}, which means that none of the parallel components produce
% any output, and there are no output items to join.
% \end{enumerate}
The splitter and joiner type are specified with calls to {\tt
setSplitter} and {\tt setJoiner}, respectively.  The EchoEffect 
uses a Duplicate splitter so that each signal appears both directly
and as an echo; it uses a RoundRobin joiner to interleave the immediate
signals with the delayed ones.  In AudioEcho, an Adder is used to 
combine each pair of interleaved signals.

The last control construct provides a way to create cycles in the
stream graph: the {\bf FeedbackLoop}.  The Fibonacci stream in Figure
\ref{fig:feed} illustrates the use of this construct.  Each FeedbackLoop
contains: 1) a joiner, to merge the feedback path with the outside
input stream at the top of the loop, 2) a body stream, which comprises
the forward path of the loop, 3) a splitter, which distributes data
between the output channel and the feedback path, and 4) a loop
stream, which can perform some computation along the feedback path.
These components are specified from within the {\tt init} function via
calls to {\tt setJoiner}, {\tt setBody}, {\tt setSplitter}, and {\tt
setLoop}, respectively.  The splitters and joiners can be any of those
for SplitJoin, except for Null.  The call to {\tt setLoop} can be
ommitted if no computation is performed along the feedback path.

The FeedbackLoop has a special semantics when the stream is first
starting to run.  Since there are no items on the feedback path at
first, the stream instead inputs items from an {\tt initPath} function
defined by the FeedbackLoop; given an index $i$, {\tt initPath}
provides the $i$'th initial input for the feedback joiner.  With a
call to {\tt setDelay} from within the {\tt init} function, the user
can specify how many items should be calculated with {\tt initPath}
before the joiner looks for data items from the feedback channel.

Evident in the Fibonnacci example of Figure \ref{fig:feed} is another
feature of the StreamIt syntax: {\it inlining}.  The definition of any
stream or filter can be inlined at the point of its instantiation,
thereby preventing the definition of many small classes that are used
only once, and, moreover, providing a syntax that reveals the
hierarchical structure of the streams from the indentation level of
the code.  In our Java syntax, we make use of anonymous classes for
inlining \cite{java}.

\subsubsection{Rationale}

StreamIt differs from other languages in that it imposes a
well-defined structure on the streams; all stream graphs are built out
of a hierarchical composition of Pipelines, SplitJoins, and
FeedbackLoops.  This is in contrast to other environments, which
generally regard a stream as a flat and arbitrary network of filters
that are connected by channels.  However, arbitrary graphs are very
hard for the compiler to analyze, and equally difficult for a
programmer to describe.  Most programmers either resort to
straight-line code that links one filter to another (thereby making it
very hard to visualize the stream graph), or using an ad-hoc graphical
programming environment that admits no good textual representation.

In contrast, StreamIt is a clean textual representation
that--especially with inlined streams--makes it very easy to see the
shape of the computation from the indentation level of the code.  The
comparison of StreamIt's structure with arbitrary stream graphs could
be likened to the difference between structured control flow and GOTO
statements.  Though sometimes the structure restricts the
expressiveness of the programmer, the gains in robustness,
readability, and compiler analysis are immense.  A graphical editor
for StreamIt would also have advantages over a purely graphical
environment, since 1) the hierarchical structure of the stream graph
would enable clear visualizations, and 2) every stream graph has a
precise textual equivalent that could also be edited by the
programmer.

On first glance, the statements within StreamIt {\tt init} functions
might appear more like a verbose API than a novel language.  However,
it was actually a careful design decision to specify all "stream
configuration information" via function calls from within the {\tt
init} functions.  While the current syntax is somewhat tedious, there
is great flexibility in this approach, since the user can intermix
configuration directives with statements that calculate the
configuration parameters.  In all, this allows for fully parameterized
graph construction--the FFT stream in Figure \ref{fig:fft-streamit}
inputs a parameter {\tt N} and adjusts the number of butterfly stages
appropriately.  This further improves readability and decreases code
size.

\subsection{Messages}

\begin{figure}[h]
\vspace{-12pt}
\psfig{figure=messaging-code.eps,width=675.44pt}
\vspace{-18pt}
\caption{The frequency-hopping of our software radio illustrates StreamIt's messaging system.  In {\tt TrunkedRadio}, a {\tt Portal} is created to hold the message target, {\tt rf2if}.  Then, {\tt CheckFreqHop} uses the {\tt Portal} to send a frequency-change message.
\protect\label{fig:portal-code}}
\vspace{-18pt}
\end{figure}

StreamIt provides a dynamic messaging system for passing irregular,
low-volume control information between filters and streams.  Messages
are sent from within the body of a filter's {\tt work} function,
perhaps to change a parameter in another filter.  For example, in the
{\tt CheckFreqHop} stream of our software radio example (Figure
\ref{fig:portal-code}), a message is sent upstream to change the frequency of
the receiver if the downstream component detects that the transmitter
is about to change frequencies.  The sender can continue to execute
while the message is en route, and the {\tt set\_freq} method will be
invoked in the receiver with argument {\tt Freq[k]} when the message
arrives.  Since message delivery is asynchronous, there can be no
return value; only void methods can be message targets.

{\bf Message timing.}The central aspect of the messaging system is a
sophisticated timing mechanism that allows filters to specify when a
message will be received relative to the flow of information between
the sender and the receiver.  Recall that each filter executes
independently, without any notion of global time.  Thus, the only way
for two filters to talk about a time that is meaningful for both of
them is in terms of the data items that are passed through the streams
from one to the other.

In StreamIt, one can specify a range of latencies for a message to get
delivered.  This latency is measured in terms of an information
``wavefront'' from one filter to another.  For example, in the {\tt
CheckFreqHop} example of Figure \ref{fig:portal-code}, the sender
indicates an interval of latencies between $4N$ and $6N$.  This means
that the receiver will receive the message immediately following the
last invocation of its own {\tt work} function which produces an item
affecting the some output of the {\it sender's} $4N$'th to $6N$'th
work functions, counting the sender's current work function as number
0.  Due to space limitations, we cannot define this notion precisely
in this paper (see \cite{streamittech620,streamittech622} for a formal
semantics), but the general idea is simple: the receiver is invoked
when it sees the information wavefront that the sender sees in $4N$ to
$6N$ execution steps.

In some cases, the ability to synchronize the arrival of a message
with some element of the data stream is very important.  For example,
{\tt CheckFreqHop} knows that the transmitter will change the
frequency between $4N$ and $6N$ steps later, in terms of the frame
that {\tt CheckFreqHop} is inputting.  To ensure that the radio
changes frequencies at the same time--so as not to lose any data at
the old or new frequency--{\tt CheckFreqHop} instructs the receiver to
switch frequencies when the {\it receiver} sees one of the last data
items at the old frequency.

% If the receiver of a message is a stream instead of a filter, then the
% message delivery is timed with respect to the first (most upstream)
% filter in the stream.  We are still formalizing the message delivery
% semantics in cases where the receiver is a stream that has no unique
% first filter (e.g., a SplitJoin with NULL splitter).  Note that the
% stream itself can receive a message even though the timing is in terms
% of filter-to-filter communication.
%
{\bf Portals for broadcast messaging.}  StreamIt also has support for
modular broadcast messaging.  When a sender wants to send a message
that will invoke method $M$ of the receiver $R$ upon arrival, it does
not call $M$ on the object $R$.  Rather, it calls $M$ on a {\it
Portal} of which $R$ is a member.  Portals are typed containers that
forward all messages they receive to the elements of the container.
Portals could be useful in cases when a component of a filter library
needs to announce a message (e.g., that it is shutting down) but does
not know the list of recipients; the user of the library can pass the
filter a Portal containing all interested receivers.  As for message
delivery constraints, the user specifies a single time interval for
each message, and that interval is interpreted separately (as
described above) for each receiver in the Portal.

In a language with generic data types, a Portal could be implemented
as a templated list.  However, since Java does not yet support
templates, we automatically generate an {\tt <X>Portal} class for
every class and interface {\tt <X>}.  Our syntax for using Portals is
evident in the {\tt TrunkedRadio} class in Figure
\ref{fig:portal-code}.

\subsubsection{Rationale}

Stream programs present a challenge in that filters need both regular,
high-volume data transfer and irregular, low-volume control
communication.  Moreover, there is the problem of reasoning about the
relative ``time'' between filters when they are running asynchronously
and in parallel.

A different approach to messaging is to embed control messages in the
data stream instead of providing a separate mechanism for dynamic
message passing.  This does have the effect of associating the message
time with a data item, but it is complicated, error-prone, and leads
to unreadable code.  Further, it could hurt performance in the steady
state (if each filter has to check whether or not a data item is
actual data or control, instead) and complicates compiler analysis,
too.  Finally, one can't send messages upstream without creating a
separate data channel for them to travel in.

Another solution is to treat messages as synchronous method calls.
However, this delays the progress of the stream when the message is en
route, thereby degrading the performance of the program and
restricting the compiler's freedom to reorder filter executions.  

We feel that the StreamIt messaging model is an advance in that it
separates the notions of low-volume and high-volume data
transfer--both for the programmer and the compiler--without losing a
well-defind semantics where messages are {\it timed} relative to the
high-volume data flow.  Further, by separating message communication
into its own category, fewer connections are needed for steady-state
data transfer and the resulting stream graphs are more amenable to
structured stream programming.

\subsection{Re-Initialization}
\label{sec:reinit}

One of the characteristics of a streaming application is the need to
occaisionally modify the structure of part of the stream graph.
StreamIt allows these changes through a re-initialization mechanism
that is integrated with its messaging model.  If a sender targets a
message at the {\tt init} function of a stream or filter $S$, then
when the message arrives, it re-executes the initialazation code and
replaces $S$ with a new version of itself.  However, the new version
might have a different structure than the original if the arguments to
the {\tt init} call on re-initialization were different than during
the original initialization.

When an init message arrives, it does not kill all of the data that is
in the stream being re-initialized.  Rather, it {\it drains} the
stream until the wavefront of information (as defined for the
messaging model) from the top of the stream has reached the bottom.
The draining occurs without consuming any data from the input channels
to the re-initialized region.  Instead, a {\tt drain} function of each
filter is invoked to provide input when its other input source is
frozen.  (Each filter can override the {\tt drain} function as part of
its definition.)  If the programmer prefers to kill the data in a
stream segment instead of draining it, this can be indicated by
sending an extra argument to the message portal with the
re-initialization message.

\subsubsection{Rationale}

Re-initialization is a headache for stream programmers because--if
done manually--the entire runtime system could be put on hold to
re-initialize a portion of the stream.  The interface to starting and
stopping streams could be complicated when there is not an explicit
notion of initialization time vs. steady-state execution time, and
ad-hoc draining techniques could risk losing data or deadlocking the
system.

StreamIt improves on this situation by abstracting the
re-initialization process from the user.  That is, no auxillary
control program is needed to drain the old streams and create the new
structure; the user need only trigger the reinitialization process
through a message.  Additionally, any hierarchical stream construct
automatically becomes a possible candidate for re-initialization, due
to the well-defined stream structure and the simple interface with the
{\tt init} function.  Finally, it is easy for the compiler to
recognize stream re-initialization possibilities and to account for
all possible configurations of the stream flow graph during analysis
and optimization.

\subsection{Latency Constraints}

Lastly, StreamIt provides a simple way of restricting the latency of
an information wavefront in traveling from the input of one filter to
the output of a downstream filter.  Issuing the directive {\tt
MAX\_LATENCY(A, B, n)} from within an {\tt init} means that $A$ can
only execute up to the wavefront of information that $B$ will see
after $n$ invocations of its own work function.



