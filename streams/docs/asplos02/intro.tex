\section{Introduction}

As we approach the billion-transistor era, a number of emerging
architectures are addressing the wire delay problem by replicating the
basic processing unit and exposing the communication between units to
a software layer ({\it e.g.}, Raw \cite{raw}, SmartMemories
\cite{smartmemories}, TRIPS \cite{trips}).  These machines are
especially well-suited for streaming applications that have regular
communication patterns and widespread parallelism.

However, today's communication-exposed architectures are lacking a
portable programming model.  If these machines are to be widely used,
it is imperative that one be able to write a program once, in a
high-level language, and rely on a compiler to produce an efficient
executable on any of the candidate targets. For von-Neumann machines,
the C programming language served this purpose; it abstracted away the
idiosyncratic details between one machine and another, but
encapsulated the common properties (such as a single program counter,
arithmetic operations, and a monolithic memory) that are necessary to
obtain good performance.  However, for wire-exposed targets that
contain multiple instruction streams and distributed memory banks, C
is obsolete.  Though C can still be used to write efficient programs
on these machines, doing so either requires architecture-specific
directives or a very smart compiler that can extract the parallelism
and communication from the C semantics.  Both of these options
disqualify C as a portable machine language, since it fails to hide
the architectural details from the programmer and it imposes
abstractions which are a mismatch for the domain.

In this paper, we describe a compiler for StreamIt, a high level
stream language that aims to be portable across communication-exposed
machines \cite{streamitcc}.  StreamIt contains basic constructs that
expose the parallelism and communication of streaming applications
without depending on the granularity of the underlying architecture.
Our current backend is for Raw \cite{raw}, a tiled architecture with
fine-grained, programmable communication between processors.  However,
the compiler consists of three general techniques that can be applied
to compile StreamIt to machines other than Raw: 1) partitioning, which
adjusts the granularity of a stream graph to match that of a given
target, 2) layout, which maps a partitioned stream graph to a given
network topology, and 3) scheduling, which generates a fine-grained
static communication pattern for each computational element.  We
consider this work to be a first step towards a portable programming
model for communication-exposed architectures.

This paper makes the following contributions:
\begin{itemize}
\item Filter fusion optimizations that combine both sequential and
parallel stream segments, even if there are buffers between nodes.
\item A filter fission optimization.
\item A graph reordering optimization.
\item An algorithm for laying out a filter graph onto a tiled architecture.
\item A communication scheduling algorithm that manages limited 
communication and buffer resources.
\item An end-to-end implementation of a parallelizing compiler for
streaming applications.
\end{itemize}

The rest of this paper is organized as follows.  Section
\ref{sec:streamit} provides an introduction to StreamIt,
Section~\ref{sec:raw} contains an overview of Raw, and
Section~\ref{sec:phases} outlines our compiler for StreamIt on Raw.
Sections \ref{sec:partition}, \ref{sec:layout}, and \ref{sec:communic}
describe our algorithms for partitioning, layout, and communication
scheduling, respectively.  Section~\ref{sec:codegen} describes code
generation for Raw, and Section~\ref{sec:results} presents our results
from the cycle-accurate Raw simulator.  Section~\ref{sec:related}
considers related work, and Section~\ref{sec:conclusion} contains our
conclusions.
