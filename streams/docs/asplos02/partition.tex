\begin{figure}
\centering
\psfig{figure=radio-graph-orig.eps,width=4in}
\caption{\protect\small Stream graph of the original FM Radio, in
which the Filters are at a granularity that is natural for the
algorithm. \protect\label{fig:fm-orig}}
\vspace{36pt}
\psfig{figure=radio-graph-opt.eps,width=4in}
\caption{\protect\small Stream graph of the load-balanced FM Radio.
Since the first LowPassFilter was the most demanding node, it was
duplicated across a 2-way SplitJoin.  Then, to conserve tiles, the
Subtract node was moved across a downstream Joiner via the Filter
Hoisting transformation.  The Subtract, Add, and Printer nodes were
then fused into a single Filter.  This configuration of the stream
graph displays much better load balancing than the original (see
Figure~\ref{fig:fm-blood}).  \protect\label{fig:fm-opt}}
\end{figure}

\begin{figure}
  \begin{center} \psfig{figure=beam-blood-key.eps,width=3.25in} \\
    \subfigure[\vspace{-6pt}
    Original.\label{fig:radio-blood1}]{\psfig{figure=radio-blood-orig.eps,width=3in}}
    \hspace{0.3in} \subfigure[\vspace{-6pt}
    Load-balanced.\label{fig:radio-blood2}]{\psfig{figure=radio-blood-opt.eps,width=3in}
    \vspace{-6pt}} \vspace{-6pt} \caption{Execution traces for the (a)
    original and (b) load-balanced partitionings of the FM Radio.  The
    $x$ axis denotes time, and the $y$ axis denotes the processor.
    The dark bands indicate periods where processors are blocked
    waiting to receive an input or send an output.  Light regions
    indicate periods of useful work.  The thin stripes in the light
    regions represent pipeline stalls.  \protect\label{fig:fm-blood}}
    \vspace{-6pt}
\end{center}
\end{figure}

\begin{figure}
\centering
\psfig{figure=fuse-pipeline.eps,width=6.5in}
\vspace{-6pt}
\caption{\protect\small Fusion of a Pipeline into a two-stage filter.
In this example, the UpSampler pushes $K$ items on every step, while the
MovingAverage filter peeks at $N$ items but only pops 1.  To accomodate
this peeking behavior, the fused filter maintains a {\tt peek\_buffer}
for the items that reside on the channel between the two filters.  In
the initial work function, which is called only on the first
invocation, the {\tt peek\_buffer} is filled with initial values from
the UpSampler.  The steady work function implements a steady-state
schedule in which $\mt{LCM}(N, K)$ items are transferred between the two
original filters--these items are communicated through a local,
temporary {\tt buffer}.  Before and after the execution of the
MovingAverage code, the contents of the {\tt peek\_buffer} are
transferred in and out of the temporary {\tt buffer}.  If the {\tt
peek\_buffer} is small, this copying can be eliminated with loop
unrolling and copy propagation.  Note that the {\tt peek\_buffer} is
for storing items that are persistent from one firing to the next,
while the local {\tt buffer} is just for communicating values during a
single firing. \label{fig:fuse-pipe}}
\vspace{-6pt}
\end{figure}

\begin{figure}
\centering
\psfig{figure=fuse-splitjoin.eps,width=4.93in}
\caption{\protect\small Fusion of a Duplicate SplitJoin construct.  To
fuse a SplitJoin with a Duplicate Splitter, the code of the component
filters is inlined into a single filter with repetition according to
the steady-state schedule.  However, there are some modifications: all
{\tt pop} statements are converted to {\tt peek} statements, and the
{\tt pop}'s are performed at the end of the fused work function.  This
allows all the filters to see the data items before they are consumed.
Finally, the RoundRobin Joiner is simulated by a ReorderRoundRobin
filter that re-arranges the output of the fused filter according to
the weights of the Joiner.  \protect\label{fig:fuse-splitjoin1}}
\vspace{-6pt}
\end{figure}

\begin{figure}
\centering
\psfig{figure=fuse-splitjoin2.eps,width=4.93in}
\caption{\protect\small Fusion of a RoundRobin SplitJoin construct.
The fusion transformation for SplitJoins containing RoundRobin
Splitters is similar to those containing Duplicate Splitters.  One
filter simulates the execution of a steady-state cycle in the
SplitJoin by inlining the code from each filter.  This filter is
surrounded by ReoderRoundRobin filters that recreate the reordering of
the RoundRobin nodes.  In the above example, the difference the
Splitter's weights, the Filter's I/O rates, and the Joiner's weights
adds complexity to the reordering.  Though this transformation is
fully automated in the StreamIt compiler, a general formulation is
beyond the scope of this paper.  \protect\label{fig:fuse-splitjoin2}}
\end{figure}

\begin{figure}
\centering
\psfig{figure=duplicate-fission-2.eps,width=4.60in}
\caption{\protect\small Fission of a filter that does not peek.  For
Filters such as a VectorMultiply that consumes every item they look
at, horizontal fission consists of embedding copies of the filter in a
$K$-way RoundRobin SplitJoin.  The weights of the Splitter and Joiner
are set to match the $pop$ and $push$ rates of the filter,
respectively.  \protect\label{fig:fission-nopeek}}
\end{figure}

\begin{figure}
\centering
\psfig{figure=duplicate-fission.eps,width=3.94in}
\caption{\protect\small Fission of a filter that peeks.  Since the
MovingAverage filter reads items that it does not consume, the
duplicated versions of the filter need to access overlapping portions
of the input stream.  For this reason, horizontal fission creates a
Duplicate SplitJoin in which each component filter has additional code
to filter out items that are irrelevant to a given path.  This
decimation occurs in two places: once in the initial work function, to
disregard items considered by previous filters on the first iteration
of the SplitJoin, and once at the end of the steady work function, to
account for items consumed by other components.
\protect\label{fig:fission-peek}}
\end{figure}

\begin{figure}
\centering
\psfig{figure=filter-hoisting.eps,width=4.81in}
\caption{\protect\small Filter hoisting.  This transformation allows a
stateless Filter to be moved across a Joiner node if its $push$ value
evenly divides the weights of the Joiner.  This proved to be very
useful in load balancing the FMRadio application.
\protect\label{fig:filter-hoisting}}
\vspace{12pt}
\psfig{figure=splitjoin-split.eps,width=5.13in}
\caption{\protect\small Breaking a SplitJoin into hierarchical units.
Though our horizontal fusion algorithms work on the granularity of an
entire SplitJoin, it is straightforward to transform a large SplitJoin
into a number of smaller pieces, as shown here.  Following this
transformation, the fusion algorithms can be applied to obtain an
intermediate level of granularity.
\protect\label{fig:splitjoin-split}}
\vspace{12pt}
\psfig{figure=sync-removal.eps,width=4.02in}
\caption{\protect\small Synchronization removal.  If a Splitter is
bordering a Joiner with identical weights, the nodes can be removed
and the component streams can be connected.  This is especially useful
in the context of libraries--many distinct components can employ
SplitJoins for processing interleaved data streams, and the modules
can be composed without having to synchronize all the streams at each
boundary.  \protect\label{fig:sync-removal}}
\vspace{-6pt}
\end{figure}

\section{Partitioning}
\label{sec:partition}

StreamIt provides the Filter construct as the basic abstract unit of
autonomous stream computation.  The programmer should decide the
boundaries of each Filter according to what is most natural for the
algorithm under consideration.  While one could envision each Filter
running on a separate machine in a parallel system, StreamIt hides the
granularity of the target machine from the programmer.  Thus, it is
the responsibility of the compiler to adapt the granularity of the
stream graph for efficient execution on a particular architecture.

We use the word {\it partitioning} to refer to the process of dividing
a stream program into a set of balanced computation units.  Given a
number $N$, which represents the maximum number of computation units
that can be supported, the partitioning stage transforms a stream
graph into a set of no more than $N$ filters, each of which performs
approximately the same amount of work during the execution of the
program.  Following this stage, each filter can be run on a separate
processor to obtain a load-balanced executable.

Load balancing is particularly important in the streaming domain,
since the throughput of a stream graph is equal to the {\it minimum}
throughput of each of its stages.  This is in contrast to scientific
programs, which often contain a number of stages which process a given
data set; the running time is the {\it sum} of the running times of
the phases, such that a high-performance, parallel phase can partially
compensate for an inefficient phase.  In mathematical terms, Amdahl's
Law captures the maximum realizable speedup for scientific
applications.  However, for streaming programs, the maximum
improvement in throughput is given by the following expression:
\begin{align*}
\mbox{\it Maximum speedup}(w, c) = \frac{\sum_{i=1}^N{w_i \cdot c_i}}{MAX_i(w_i \cdot c_i)}
\end{align*}
where $w_1 \dots w_m$ denote the amount of work in each of the $N$
partitions of a program, and $c_i$ denotes the multiplicity of work
segment $i$ in the steady-state schedule.  Thus, if we double the load
of the heaviest node ({\it i.e.}, the node with the maximum $w_i \cdot
c_i$), then the performance could suffer by as much as a factor of
two.  The impact of load balancing on performance places particular
value on the partitioning phase of a stream compiler.
% This can be posed in
% mathematical terms by appealing to Amdahl's Law, which expresses the
% maximum speedup that can be achieved on $N$ processors when there are
% $S_1 \dots S_x$ units of sequential work and $P_1 \dots P_y$ units of
% parallel work:
% \begin{align*}
% \mbox{\it Maximum speedup}(S, P, N) = \frac{\sum_{i=1}^x{S_i}+\sum_{i=1}^y{P_i}}{\sum_{i=1}^x{S_i}+\frac{\sum_{i=1}^y{P_i}}{N}}
% \end{align*}
% However, in a stream program, the measure of performance is throughput
% rather than running time.  Using $w_1 \dots w_m$ to denote the amount
% of work in each of the $m$ partitions of a program, and denoting the
% multiplicity of work segment $i$ in the steady-state schedule by
% $c_i$, we have that:

\subsection{Overview}

Our partitioner employs a set of fusion, fission, and reordering
transformations to incrementally adjust the stream graph to the
desired granularity.  To achieve load balancing, the compiler
estimates the number of instructions that are executed by each filter
in one steady-state cycle of the entire program; then, computationally
intensive filters can be split, and less demanding filters can be
fused.  Currently, the decision of which transformations to apply is
done by hand, but the transformations themselves are fully automated.

We use the BeamFormer application \cite{pca} to illustrate the
partitioning process (see Section~\ref{sec:results} for more
information about the BeamFormer).  The original partitioning of the
BeamFormer (Figure~\ref{fig:fm-orig}) is highly unbalanced, as the
$\mbox{FIRFilter}_3$ nodes constitute most of the work in the stream
graph.  Figure~\ref{fig:fm-blood1} provides an execution trace of the
original partitioning and demonstrates that these two filters are the
bottleneck for the entire computation.  The StreamIt compiler performs
four vertical fusion transformations and two five-way horizontal
fission transformations to obtain the load-balanced stream graph given
in Figure~\ref{fig:fm-opt}.  As illustrated by the execution trace in
Figure~\ref{fig:fm-blood2}, the optimized graph achieves approximately
five times as much processor utilization as the original, since the
computationally intensive nodes have been split and the lighter nodes
have been combined. In the following sections, we describe these
transformations in more detail.

\subsection{Fusion Transformations}

Filter fusion is a transformation whereby several adjacent filters are
combined into one.  Fusion can be applied to decrease the granularity
of a stream graph so that an application will fit on a given target,
or to improve load balancing by merging small filters so that there is
space for larger filters to be split.  Analogous to loop fusion in the
scientific domain, filter fusion can enable other optimizations by
merging the control flow graphs of adjacent nodes, thereby shortening
the live ranges of variables and allowing independent instructions to
be reordered.

\subsubsection{Vertical Fusion}

Vertical fusion describes the combination of sequential, pipelined
filters into a single unit.  We have developed a vertical fusion
algorithm for StreamIt filters that we describe below.  For the more
limited domain of filters that do not contain peek statements,
Proebsting and Watterson \cite{pro96} present a filter fusion
algorithm that interleaves the control flow graphs of adjacent nodes.
However, they assume that nodes communicate via synchronous {\tt get}
and {\tt put} operations, such that StreamIt's asynchronous peek
operations and implicit buffer management fall outside the scope of
their model.

Our algorithm relies on the static I/O rates of each filter to
calculate a legal execution ordering for the filters being fused.
Then, the fused filter simulates the execution of this schedule,
inlining the code from each of the original filters and using local
variables for buffering.  In our current implementation, the scheduler
computes only the multiplicity of each component filter in relation to
the fused filter; then, the fused code is a sequence of loops that
each execute a component filter for the appropriate multiplicity,
buffering its results in a local array.  If the multiplicity is small,
then the loop can be unrolled and all array references can be replaced
with scalar variables to facilitate optimization.

A subtlety of our algorithm is that the fused filter differs from the
originals in that it has two distinct execution phases: one for
initialization, and one for steady-state execution (see
Figure~\ref{fig:fuse-pipe}).  If any of the component filters peek at
elements that they do not consume, then a separate initialization
schedule is required to fill all the ``peek buffers'' in the pipeline
(see Section~\ref{sec:phases}).  During this initialization, the
pipeline as a whole will consume some input, but will not produce any
output.  Then, during the steady state schedule, the sizes of the
buffers are preserved, and the pipeline both produces and consumes
items.  Thus, when there is peeking in the stream, there will be
different I/O rates for the initialization and steady-state phases,
and the fused filter will be a {\it two stage filter}: it executes one
work function on its first invocation, and a separate work function on
all subsequent invocations.  Though these work functions may have
different I/O rates, each rate is constant and known at compile time.

\subsubsection{Horizontal Fusion}

We refer to the combination of the parallel streams in a SplitJoin
construct as ``horizontal fusion''.  Our horizontal fusion algorithm
inputs a SplitJoin where each component is a single filter, and
outputs a Pipeline of three filters: one to emulate the Splitter, one
to simulate the execution of the parallel filters, and one to emulate
the Joiner.  The Splitters and Joiners need to be emulated in case
they are RoundRobin's that perform some reordering of the data items
with respect to the component streams.  Generally speaking, the fusion
of the parallel components is similar to that of vertical fusion--a
sequential steady-state schedule is calculated, and the component work
functions are inlined and executed within loops.  However, horizontal
fusion requires no buffering of internal items, as the parallel
streams do not communicate with each other.

The details of our horizontal fusion transformation depend on the type
of the Splitter in the construct of interest.  There are two cases:
\begin{enumerate}
\item For {\bf Duplicate} Splitters, the {\tt pop} expressions from
component filters need to be converted to {\tt peek} expressions so
that items are not consumed before subsequent filters can read them
(see Figure~\ref{fig:fuse-splitjoin1}).  Then, at the end of the fused
work function, the items consumed by an iteration of the SplitJoin are
popped from the input channel.  Also, the Splitter itself performs no
reordering of the data, so it translates into an Identity filter that
can be removed from the stream graph.  This fusion transformation is
valid even if the component Filters peek at items which they do not
consume.

\item For {\bf RoundRobin} Splitters, the {\tt pop} expressions in
component filters are left unchanged, and the RoundRobin Splitter is
emulated in order to reorder the data items according to the weights
of the Splitter and the consumption rates of the component streams
(see Figure~\ref{fig:fuse-splitjoin2}).  However, this transformation
is invalid if any of the component Filters peeks at items which it
does not consume, since the interleaving of items on the input stream
of the fused filter prevents each component from having a continuous
view of the items that are intended for it.  Thus, we only apply this
transformations when all component Filters have $peek = pop$.
\end{enumerate}

A more mathematical description of our horizontal fusion
transformation is given in \cite{streamittech2}.

\subsection{Fission Transformations}

Filter fission is the analog of parallelization in the streaming
domain.  It can be applied to increase the granularity of a stream
graph to utilize unused processor resources, or to break up a
computationally intensive node for improved load balancing.

\subsubsection{Vertical Fission}

Some filters can be split into a pipeline, with each stage performing
some part of the {\tt work} function.  In addition to the original
input data, these pipelined stages might need to communicate
intermediate results from within {\tt work}, as well as fields within
the filter.  This scheme could apply to filters with state if all
modifications to the state appear at the top of the pipeline (they
could be sent over the data channels), or if changes are infrequent
(they could be sent via StreamIt's messaging system.)  Also, some
state can be identified as induction variables, in which case their
values can be reconstructed from the {\tt work} function instead of
stored as fields.  We have yet to automate vertical filter fission in
the StreamIt compiler.

\subsubsection{Horizontal Fission}

We refer to ``horizontal fission'' as the process of distributing a
single filter across the parallel components of a SplitJoin.  We have
implemented this transformation for ``stateless'' filters--that is,
filters that contain no fields that are written on one invocation of
{\tt work} and read on later invocations.  Let us consider such a
filter $F$ with I/O rates of $peek$, $pop$, and $push$, that is being
parallelized into an $K$-way SplitJoin.  There are two cases to
consider:
\begin{enumerate}
\item If {\bf $peek = pop$}, then $F$ can simply be duplicated $K$
ways in the SplitJoin (see Figure~\ref{fig:fission-nopeek}).  The
Splitter is a RoundRobin that routes $pop$ elements to each copy of
$F$, and the Joiner is a RoundRobin that reads $push$ elements from
each component.  Since $F$ does not peek at any items which it does
not consume, its code does not need to be modified in the component
streams--we are just distributing the invocations of $F$.

\item If {\bf $peek > pop$}, then our transformation produces a
SplitJoin that has a set of two-stage filters as its components (see
Figure~\ref{fig:fission-peek}.  In this case, the Splitter is a
Duplicate, since the component filters need to examine overlapping
parts of the input stream.  The $i$'th component has a steady-state
work function that begins with the work function of $F$, but appends a
series of $(K-1)*pop$ pop statements in order to account for the data
that is consumed by the other components.  Also, the $i$'th filter has
an initialization work function that pops $(i-1)*pop$ items from the
input stream, to account for the consumption of previous filters on
the first iteration of the SplitJoin.  As before, the Joiner is a
RoundRobin that has a weight of $push$ for each stream.
\end{enumerate}

\subsection{Reordering Transformations}
There are a multitude of ways to reorder the elements of a stream
graph so as to facilitate fission and fusion transformations.  For
instance, identical stateless filters can be pushed through a Splitter
or Joiner node if the weights are adjusted accordingly
(Figure~\ref{fig:filter-hoisting}); a SplitJoin construct can be
divided into a hierarchical set of SplitJoins to enable a finer
granularity of fusion (Figure~\ref{fig:splitjoin-split}); and
neighboring Splitters and Joiners with matching weights can be
eliminated (Figure~\ref{fig:sync-removal}).

\subsection{Summary}

We have described fission and fusion transformations for a large
domain of stream constructs.  Our vertical fusion transformation
applies to any sequence of filters, with or without peeking; our
horizontal fusion transformation supports peeking if the Splitter is a
Duplicate, but not if the Splitter is a RoundRobin.  Our horizontal
fission algorithm Duplicates any stateless filter into a SplitJoin
construct of arbitrary width.

The one domain that we have left unexplored is the fusion and fission
of two-stage filters.  If a two-stage filter (with a non-empty initial
work function) results from one transformation, then no subsequent
transformations can be safely performed on them.  We are currently
extending our transformations to support two-stage filters.



